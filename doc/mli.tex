% Copyright (C) 2017, 2021-2022 Hans Ã…berg.
%
% This file is part of MLI, MetaLogic Inference.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
%
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
%
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.


% In order to see math styled letters and indices, use the following two inputs,
% followed by the stixfont command after the texinfo input:
\input luaotfload.sty
\input luatex-math-modified.tex

\input texinfo @c -*-texinfo-*-

@stixfont

@comment %**start of header
@setfilename mli.info
@documentencoding UTF-8
@documentlanguage en
@include version.texi
@settitle MetaLogic Inference @value{VERSION}
@setchapternewpage odd

@finalout

@c SMALL BOOK version
@c This edition has been formatted so that you can format and print it in
@c the smallbook format.
@c @smallbook

@c Set following if you want to document %default-prec and %no-default-prec.
@c This feature is experimental and may change in future MLI versions.
@c @set defaultprec

@ifnotinfo
@syncodeindex fn cp
@syncodeindex vr cp
@syncodeindex tp cp
@end ifnotinfo
@ifinfo
@synindex fn cp
@synindex vr cp
@synindex tp cp
@end ifinfo
@comment %**end of header

@copying

This manual (@value{UPDATED}) is for GNU MLI (version
@value{VERSION}), the GNU MetaLogic Inference program.

Copyright @copyright{} 2017 Hans Ã…berg

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License,
Version 1.3 or any later version published by the Free Software
Foundation; with no Invariant Sections, with the Front-Cover texts
being ``A GNU Manual,'' and with the Back-Cover Texts as in
(a) below.  A copy of the license is included in the section entitled
``GNU Free Documentation License.''

(a) The FSF's Back-Cover Text is: ``You have the freedom to copy and
modify this GNU manual.  Buying copies from the FSF
supports it in developing GNU and promoting software
freedom.''
@end quotation
@end copying

@dircategory Software development
@direntry
* mli: (mli).       GNU MetaLogic Inference Program
@end direntry

@titlepage
@title MLI
@subtitle The MetaLogic Inference Program
@subtitle @value{UPDATED}, MLI Version @value{VERSION}

@author by Hans Ã…berg

@page
@vskip 0pt plus 1filll
@insertcopying
@sp 2
Published by the Free Software Foundation @*
51 Franklin Street, Fifth Floor @*
Boston, MA  02110-1301  USA @*
Printed copies are available from the Free Software Foundation.@*
ISBN 1-234567-89-0
@sp 2
@end titlepage

@contents

@ifnottex
@node Top
@top MLI
@insertcopying
@end ifnottex

@menu
* Introduction::
* Conditions::
* Copying::         The GNU General Public License: copy and share.


Tutorial sections

* Concepts::      The Concepts of MLI.
* Examples::      Simple explained examples.

Reference sections

* Input File::    Writing MLI declarations and rules.
* Interface::     User in interface.
* Algorithm::     The MLI inference algorithm.

* Debugging::     Understanding and debugging MLI source code.

* Invocation::    How to run MLI


Reference sections:
* Table of Symbols::    MLI keywords, with explanation.
* Glossary::            Basic concepts are explained.
* Bibliography::        Publications cited in this manual.
* Index of Terms::      Cross-references to the text.


@detailmenu
 --- The Detailed Node Listing ---

The Concepts of MLI

* Metatheory and Object Theory:: Formal structure of mathematics.
* Formal Theories and Formal Proofs:: Formal structure of mathematics.
* Proof Trees and Unification:: Formal structure of mathematics.
* The Propositional Calculus:: Formal structure of mathematics.
* The Predicate Calculus (Quantification Theory):: Formal structure of mathematics.
* Theory with Equality:: Formal structure of mathematics.
* Formal Number Theory:: Formal structure of mathematics.
* Axiomatic Set Theory:: Formal structure of mathematics.

Examples

* Simple Propositional Calculus:: Examples

* Nested proofs::   Simple Propositional Calculus.


Debugging

* MLI Options::       The options available described in detail.
* Option Cross Key::  Alphabetical list of options.


@end detailmenu
@end menu

@node Introduction
@unnumbered Introduction
@cindex introduction

@dfn{MLI}, the MetaLogic Inference program, is a theorem prover that supports breadth-first proof tree searches, and unification branching where the substitutions may have attached conditions. It starts at the metatheory level, by defining axioms and rules of inference for the metamathematics of your choice, proceeding towards the mathematical object theory.

This edition corresponds to version @value{VERSION} of MLI.

@node Conditions
@unnumbered Conditions for Using MLI

The distribution terms for MLI-generated proofs permit using them with free citizens,
as long as it does not contravene International Conventions of Humans Rights.

@node Copying
@unnumbered GNU GENERAL PUBLIC LICENSE
@include gpl-3.0.texi

@node Concepts
@chapter The Concepts of MLI

This chapter introduces some basic metalogical concepts without which the MLI program will not make much sense, both in details and general structure. If you are not already well versed in metamathematics, this chapter may be of benefit. There is though no particular about MLI relative what is found in the standard literature.

@menu
* Metatheory and Object Theory:: Formal structure of mathematics.
* Formal Theories and Formal Proofs:: Formal structure of mathematics.
* Proof Trees and Unification:: Formal structure of mathematics.
* The Propositional Calculus:: Formal structure of mathematics.
* The Predicate Calculus (Quantification Theory):: Formal structure of mathematics.
* Theory with Equality:: Formal structure of mathematics.
* Formal Number Theory:: Formal structure of mathematics.
* Axiomatic Set Theory:: Formal structure of mathematics.
@end menu


@node Metatheory and Object Theory
@section Metatheory and Object Theory

@cindex mathematics
@cindex metamathematics
@cindex metalogic

@cindex metatheory
@cindex theory, meta
@cindex object theory
@cindex theory, object



Standard mathematics deals with mathematical objects, such as numbers and sets, and other logical objects, which are described using logical statements. There is in general no direct way to asses the truth of these statements, so instead, one is using proofs, following certain rules that they must obey. The mathematical objects and statements belong to the @dfn{object theory}, whereas the proofs belong to the @dfn{metatheory}.


@cindex naive set theory
@cindex set theory, naive
@cindex axiomatic set theory
@cindex set theory, axiomatic

Standard mathematics uses mathematical objects and logical reasoning around them in an intuitive manners, which may, using computer terminology, be described as an interface towards the underlying formal metamathematical (metalogical) theory. For example, mathematicians use @dfn{naive set theory}, whereas the formal metamathematics defines different systems of @dfn{axiomatic set theory}, that act as an implementation, and is typically not used directly in the standard mathematics. MLI start at this formal level, but allows interfaces be built in the form of @dfn{theories} which approach that of standard mathematics.


@cindex consistent formal theory
@cindex formal theory, consistent

The formalization of mathematics and metamathematics started in the early 1900s, though the distinction between the two is earlier, in an attempt to resolve certain paradoxes, that roughly can be describes as being caused by self-reference, similar to functions and macros in computing that end up in non-termination (or infinite loop). The hope was to fairly quickly develop a @dfn{consistent} formal theory, i.e., without logical contradictions, but the result was unexpected:


@cindex first order logic
@cindex quantifiers
@cindex theorem without proof
@cindex Cantor diagonal proof
@cindex GÃ¶del incompleteness theorem
@cindex diagonal proof, Cantor
@cindex incompleteness theorem, GÃ¶del
@cindex algebraic number
@cindex number, algebraic
@cindex transcendental number
@cindex number, transcendental

If roughly adding a @dfn{first order logic}, i.e., with @dfn{quantifiers} of the mathematical objects, but not of the logical statements, plus the axioms of natural numbers including mathematical induction, then not all statements have a proof: Similar to the the Cantor proof of the set of real numbers having a larger cardinality than a countable set, GÃ¶del found that the set of proofs can be enumerated, but not the set of logical statements in a first order logic containing the natural numbers and the induction axiom. Thus, there must be a lot of statements that have no proof, but one has not found any explicit such statement. For comparison, the set of algebraic numbers is countable, and the set of real numbers is uncountable, but one have found a lot of explicit transcendental numbers, i.e., numbers that are not algebraic, like @math{e} and @math{Ï€}, etc.

@cindex algorithm
@cindex generalized Turing machine
@cindex Turing machine, generalized

The set of proofs correspond in a certain sense to the set of algorithms that a computer in the form of a generalized Turing machine, with infinite time and memory, can produce.


@node Formal Theories and Formal Proofs
@section Formal Theories and Formal Proofs

@cindex formal theory
@cindex well-formed formula
@cindex formula, well-formed
@cindex rule of inference
@cindex inference, rule of
@cindex postulate
@cindex axiom
@cindex direct consequence
@cindex mathematical boldface
@cindex boldface, mathematical
@cindex mathematical italic
@cindex italic, mathematical
@cindex proves symbol
@cindex symbol, proves
@cindex clause
@cindex clause head
@cindex head, clause
@cindex clause body
@cindex body, clause

@cindex notation, constant
@cindex notation, variable


A @dfn{formal theory} has a countable infinite set of symbols @math{ğ’®}, and a superset of @dfn{(well-formed) formulas} @math{â„±}, formed by certain rules. In addition, there are @dfn{rules of inference}, also called @dfn{postulate}, defined as @dfn{relations} of the form
@display
@math{ğ‘·_0, â€¦, ğ‘·_{ğ‘˜-1} âŠ¢ ğ‘·}
@end display
which allows one to check satisfiability for members @math{ğ¹_0, â€¦, ğ¹_{ğ‘˜ - 1}} and @math{ğ¹} of @math{â„±}, in which case, one says that formula @math{ğ¹} is a @dfn{direct consequence} of the formulas @math{ğ¹_0, â€¦, ğ¹_{ğ‘˜ - 1}}, the application of this specific rule explicitly given or implied by the context. The letter @math{ğ‘·} is here in boldface as a suggestion of representing a multitude, usually infinite, of formulas in @math{â„±}, and in italic as a suggestion is is a variable that can be substituted, but these are just conventions to aid human readability, and are not required by MLI. Constants are then typically rendered in an upright font, but these conventions are not rigorously adhered to.

Here, we allow @math{ğ‘˜ = 0, 1, â€¦}; when @math{ğ‘˜ = 0} it is called an @dfn{axiom}, otherwise, when @math{ğ‘˜ > 0} a @dfn{rule}. In traditional computing terminology, the formula @math{ğ¹} is called the @dfn{head} and the formula sequence @math{ğ¹_0, â€¦, ğ¹_{ğ‘˜ - 1}} the @dfn{body} of the rule of inference, the latter which is also called a @dfn{clause}.


@cindex Prolog, stack order
@cindex first-depth proof tree search
@cindex proof tree search, first-depth

For those familiar with Prolog, the same may be written
@math{ğ‘· \,{:}{-} ğ‘·_0, â€¦, ğ‘·_{ğ‘˜-1}}
implying that the body @math{ğ‘·_0, â€¦, ğ‘·_{ğ‘˜-1}} is executed in strict stack order, which is also called a @dfn{first-depth} proof tree search. A problem with this Prolog interpretation is that the shallower parts of the proof tree will not be searched if there are new alternatives added that make the search infinite.


@cindex first-breadth proof tree search
@cindex proof tree search, first-breadth

In formal proof theory is there is no such implied proof order, and MLI supports the use of @dfn{first-breadth} proof tree searches, making sure that the shallowest depth of the proof tree search always deepens, thus systematically exhausting the full proof tree. In fact, one may write @math{ğ‘·_0, â€¦, ğ‘·_{ğ‘˜-1}} as a set @math{ğ“Ÿ} and write @math{ğ“Ÿ âŠ¢ ğ‘·}.


@cindex modus ponens
@cindex MP
@cindex metalogic variable
@cindex variable, metalogic
@cindex implication symbol
@cindex symbol, implication
@cindex mathematical style
@cindex style, mathematical

A fundamental inference rule is @dfn{modus ponens}, abbreviated @dfn{MP}:
@display
@math{ğ‘¨, ğ‘¨ â‡’ ğ‘© âŠ¢ ğ‘©}
@end display
That is, @math{ğ‘©} is a direct consequence of @math{ğ‘¨}Â and @math{ğ‘¨ â‡’ ğ‘©}, or alternatively @math{ğ‘¨}Â and @math{ğ‘¨ â‡’ ğ‘©} allows one to infer (prove) @math{ğ‘©}, or for short, @math{ğ‘¨}Â and @math{ğ‘¨ â‡’ ğ‘©} proves @math{ğ‘©}.
In MLI, the corresponding code is
@example
rule MP. formula ğ‘¨, ğ‘©. ğ‘¨, ğ‘¨ â‡’ ğ‘© âŠ¢ ğ‘©.
@end example
Here, it is necessary to indicate that it is an inference rule (@code{rule}) and name it (@code{MP}), to explicitly type the variables @code{ğ‘¨}Â and @code{ğ‘©} representing formulas in a substitution, and to terminate the statement with a dot. The choice of mathematical style for @code{ğ‘¨}Â and @code{ğ‘©} is arbitrary, but the parser expects the symbols @code{â‡’} and @code{âŠ¢}, which are tied to the object theory and the metatheory respectively, and have suitable precedences for the pretty-printing. Spaces are needed just to separate certain symbols, such as identifiers, and layout does not matter. Variables occurring frequently can be declared in the body of the context they belong to, for example:
@example
formal system.
  formula ğ‘¨, ğ‘©.
  rule MP. ğ‘¨, ğ‘¨ â‡’ ğ‘© âŠ¢ ğ‘©.
end formal system.
@end example


@cindex formal proof
@cindex provability

A @dfn{formal proof} of a statement @math{ğ‘„} is then a sequence of formulas @math{ğ‘„_0, â€¦, ğ‘„_{n-1}} such that each @math{ğ‘„_ğ‘–} is a direct consequence of the preceding formulas. In other words, each @math{ğ‘„_ğ‘–} appears in the head of a rule of inference, with its body having formulas preceding it, unless it is an axiom, requiring no further validation. Thus, the set of @dfn{provable} formulas is generated by the axioms, and iteratively applying the rules of inference.

A notation for this is
@display
@math{ğ‘„_0, â€¦, ğ‘„_{ğ‘˜-1} âŠ¢_ğ’œ ğ‘„}
@end display
where @math{ğ’œ}Â is the set of inference rules and statements treated as axioms, requiring no further validation. Often, though, the index @math{ğ’œ} is often dropped, implied by the context, giving rise to the notation
@display
@math{ğ‘„_0, â€¦, ğ‘„_{ğ‘˜-1} âŠ¢ ğ‘„}
@end display
which confusingly looks exactly the same as for the one rules above. In practise, though, it is convenient, as the latter may be treated as a rule of inference if one for some reason would like treat it as a conjecture, and examine its consequences.

In addition, in practice, the @math{ğ‘„_ğ‘–} are required to only be already proved statements, and not necessarily direct consequences of a rule of inference, as it then can be expanded into a formal proof at will. Just as in the case of fules of inference, one may indicate the set of formulas already proven by a letter @math{ğ’¬}, and write @math{ğ’¬ âŠ¢_ğ’œ ğ‘„} or @math{ğ’¬ âŠ¢ ğ‘„} if @math{ğ‘„} follows from them, but this notation implies that there is a strict order among them in which the deduction has been carried out.

This type of notation, though, is convenient in MLI, as the program can do searches among formulas to find a valid proof. Each proof will then imply a strict deduction order. There may be more than one proof and deduction order, but normally, one is just interested in finding one.
Using the @dfn{generalization axiom} (cf.@ @ref{Bibliography,,Mendelson 1964}, sec.@ 2.3)
@example
rule Gen. formula ğ‘¨. ğ‘¨ âŠ¢ âˆ€ğ’™ ğ‘¨.
@end example
a statement with a long proof may look like
@example
lemma X2. formula A, C.
  A, âˆ€x A â‡’ C âŠ¢ âˆ€x C.
proof.
  1. A by premise.
  2. âˆ€x A by 1, Gen.
  3. âˆ€x A â‡’ C by premise.
  4. C by 2, 3, MP.
  conclusion by 4, Gen.
âˆ
@end example
but by the MLI proof searching capabilities, shortened to
@example
lemma X2. formula A, C.
  A, âˆ€x A â‡’ C âŠ¢ âˆ€x C.
proof.
  conclusion by Gen, premise, MP.
âˆ
@end example
Here, @code{conclusion} indicatesÂ the right hand side of the @code{âŠ¢} (or head of the clause), and @code{premise} indicates any of the statements of the left hand side of the @code{âŠ¢} (or member of the body of the clause). The long proof has the advantage of being being more specific, resulting in a shorter proof tree search, but the short proof is more convenient for experienced users, though a too unspecific proof may result in overflow in the use of computer resources, time and space. Given a short proof, a long proof can be extracted from the log file by enabling suitable tracing; @pxref{Debugging}.

@node Proof Trees and Unification
@section Proof Trees and Unification

@cindex proof tree
@cindex unification
@cindex substitution

In practice, though one has a statement, and wants to find a proof for it, as a means of verification. Then, one may search the set of inference rules from matching of their heads by a process called @dfn{unification}, which in MLI produces a set of substitutions with a condition attached to each. When a match is found, that is, the set is non-empty, and apply in succession the substitution of the matching rule and add its condition. This produces new set of formulas that much be searched backwards, until hopefully one branch results in just axioms that need no further verification.

@cindex goal

The set of conditions that must be proved is in computing called @dfn{goals}. One typically starts off with just one goal, which during the proof tree search expands, until it finally can be reduced to zero via axioms or other already proved statements. It may happen, though, that the proof tree search becomes too large, or extensive, and must be picked down, and has been mentioned before, in general, not all statements have proofs. @xref{Metatheory and Object Theory}.


@cindex free in
@cindex not free in
@cindex Kleenean algebra
@cindex algebra, Kleenean


â€” Condition @dfn{free in} and type @dfn{Kleenean}.


@node The Propositional Calculus
@section The Propositional Calculus

@cindex propositional calculus
@cindex calculus, propositional
@cindex modus ponens
@cindex quantifiers
@cindex tautology
@cindex metatheorem
@cindex excluded middle
@cindex Boolean logic
@cindex intuitionistic propositional calculus
@cindex Heyting algebra

The simplest of formal systems, the @dfn{propositional calculus}, has only logic axioms and one rule of inference, @dfn{modus ponens}, and thus no @dfn{quantifiers}. A statement which is true for all substitutions of its logical variables is called a @dfn{tautology}. A fundamental @dfn{metatheorem}, or a theorem about the metatheory, for the propositional calculus is that a statement is provable exactly when it is a tautology. Thus, to prove a statement, one can plug in all truth values in a @dfn{truth table} and verify that the statement expression is trueâ€”the metatheorem guarantees there is proof. Alternatively, one can find a proof, and then the truth table verification becomes unnecessary. Since if there are @math{ğ‘˜} variables, there will be @math{2^ğ‘˜} possibilities to verify, this will quickly become difficult to work out, at least by hand, even though a computer might still be able to do it. But for an infinitude of formulas, one will have to resort to the proofs alone. This is in fact what happens when adding quantifiers.

This said so far relates to the Boolean logic, where every statement with no variables is true or false, also called the @dfn{excluded middle}. An alternative logic theory is @dfn{intuitionistic propositional calculus}, which does not have the excluded middle axiom, and leads to a @dfn{Heyting algebra} logic.


@cindex â‡’
@cindex logical implication
@cindex implication, logical
@cindex Â¬
@cindex logical negation
@cindex negation, logical
@cindex consistent
@cindex âˆ§
@cindex logical and
@cindex and, logical
@cindex âˆ¨
@cindex logical or
@cindex or logical
@cindex â‡”
@cindex logical equivalence
@cindex equivalence, logical
@cindex definition
@cindex ğ•¥
@cindex logical true
@cindex true, logical
@cindex ğ•—
@cindex logical false
@cindex false, logical
@cindex logical atom
@cindex atom, logical
@cindex constant
@cindex deduction theorem
@cindex theorem, deduction
@cindex classical system
@cindex system, classical
@cindex intuitionistic system
@cindex system, intuitionistic


For future reference, here is the complete MLI code for the propositional calculus by Åukasiewicz @code{LL} in file @code{std/LL.mli}, cf.@ @ref{Bibliography,,Mendelson 1964}. It has just three axioms, and two symbols, unary prefix @dfn{logical negation} @code{Â¬} and binary infix @dfn{logical implication} @code{â‡’}, making it easy to show that it is @dfn{consistent}, that is, having no contradictions, in which case, it would collapse, becoming nonsensical. The other logical symbols, @dfn{logical and} @code{âˆ§} and @dfn{logical or} @code{âˆ¨}, as well as @dfn{logical equivalence} @code{â‡”}, are introduced as @dfn{definitions}. From the formal point of view, they are not thought of as being a part of the formal system, but are expanded into the axiomatic theory with fewer primitives, simplifying proofs, but form the point of a user interface, there is no practical difference from a theory having them defined as part of axioms. In addition, the truth values @dfn{logical true} @code{ğ•¥} and @dfn{logical false} @code{ğ•—} are not a part of these logical theories, but are here entered as constants, called @dfn{atoms}. And the @dfn{deduction theorem} (DT) is a @dfn{metatheorem}, and therefore entered as an axiom.

@cindex LL

@example
theory L. -- Propositional calculus by Åukasiewicz, cf. Mendelson, p. 31:
  formal system.
    atom ğ•—, ğ•¥. -- False, true. Not in core of theory L.
    formula ğ‘¨, ğ‘©, ğ‘ª.

  -- These axioms are called A1-A3 in Mendelson:
  axiom L1. ğ‘¨ â‡’ (ğ‘© â‡’ ğ‘¨).
  axiom L2. (ğ‘¨ â‡’ (ğ‘© â‡’ ğ‘ª)) â‡’ ((ğ‘¨ â‡’ ğ‘©) â‡’ (ğ‘¨ â‡’ ğ‘ª)).
  axiom L3. (Â¬ğ‘© â‡’ Â¬ğ‘¨) â‡’ ((Â¬ğ‘© â‡’ ğ‘¨) â‡’ ğ‘©).

  -- Modus ponens:
  rule MP. ğ‘¨, ğ‘¨ â‡’ ğ‘© âŠ¢ ğ‘©.

  -- Deduction theorem:
  postulate DT. formula ğ‘¨, ğ‘©. (ğ‘¨ âŠ¢ ğ‘©) âŠ¢ ğ‘¨ â‡’ ğ‘©.

  definition D1. ğ‘¨ âˆ§ ğ‘© â‰” Â¬(ğ‘¨ â‡’ Â¬ğ‘©).  
  definition D2. ğ‘¨ âˆ¨ ğ‘© â‰” (Â¬ğ‘¨) â‡’ ğ‘©.
  definition D3. ğ‘¨ â‡” ğ‘© â‰” (ğ‘¨ â‡’ ğ‘©) âˆ§ (ğ‘© â‡’ ğ‘¨).
  axiom D4. ğ•¥.
  definition D5. ğ•— â‰” Â¬ğ•¥.

  end formal system.
end theory L.
@end example

@cindex LK
@cindex LI

These axioms are for the @dfn{classical system}, where the values are Boolean algebra truth @code{ğ•¥} or false @code{ğ•—}. For the @dfn{intuitionistic system}, see the theory @code{LI} in file @code{std/LI.mli}, which is the same as the Kleene theory @code{LK} in file @code{std/LK.mli} with the exception of an axiom for logical negation: The classical axiom @code{
Â¬Â¬ğ‘¨ â‡’ ğ‘¨} is in intuitionistic logic replaced by @code{Â¬ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘©)}.

@cindex LHA
@cindex LR

There are other axiomatizations as well: Hilbert-Ackerman @code{LHA} in file @code{std/LHA.mli}, Rosser @code{LR} in file @code{std/LR.mli}.


@node The Predicate Calculus (Quantification Theory)
@section The Predicate Calculus (Quantification Theory)

@cindex predicate calculus
@cindex calculus, predicate
@cindex quantification theory
@cindex theory, quantification
@cindex first order theory
@cindex theory, first order


@node Theory with Equality
@section Theory with Equality

@cindex theory with equality
@cindex equality, theory with



@node Formal Number Theory
@section Formal Number Theory

@cindex number theory, formal
@cindex theory, formal number
@cindex theory, number



@node Axiomatic Set Theory
@section Axiomatic Set Theory

@cindex axiomatic set theory
@cindex theory, axiomatic set
@cindex set theory, axiomatic
@cindex theory, axiomatic set
@cindex theory, set



@node Examples
@chapter Examples
@cindex simple examples
@cindex examples, simple

With the help of examples, we will now show some basic features: How to write a long and short proofs, and to convert them, making condensed proofs more efficient with respect to used computer resources, and some basic debugging.


@menu
* Simple Propositional Calculus:: Examples
@end menu


@node Simple Propositional Calculus
@section Simple Propositional Calculus

@cindex deduction theorem
@cindex DT
@cindex lemma
@cindex proposition
@cindex theorem
@cindex corollary
@cindex subproof
@cindex claim

The point of departure is the propositional calculus, or logic theory, by Åukasiewicz, called @code{LL} in the MLI library file @code{std/LL.mli}. We run through some of the theorems in connection with the Deduction Theorem (DT). The text here is self-contained, so no immediate outside sources are required for an immediate understanding of the examples, but for a comparison, see for example @ref{Bibliography,,Mendelson 1964}.

@menu
* Nested proofs::   Simple Propositional Calculus.
@end menu


In the proof of that the theory LL satisfies the Deduction Theorem DT, it is needed that for all formulas @code{ğ‘¨}, one can prove @code{ğ‘¨ â‡’ ğ‘¨}, which in MLI code becomes:
@example
lemma â€œXL.1â€. formula ğ‘¨. ğ‘¨ â‡’ ğ‘¨.
@end example
As the name contains a non-alphanumerical character, the dot, it must be put in quotes. Here we call it a @code{lemma}, as it is intended as assistance in the proof of the upcoming theorem, the Deduction Theorem, but it is logically equivalent to a @code{theorem}. Other, logically equivalent, names that might be used are @code{proposition}, a less important theorem, and @code{corollary}, though to be consequence of another theorem. Subproof statements are labeled with @code{claim}â€”see below.

The statement is about provability, that there is a formal proof of @code{ğ‘¨ â‡’ ğ‘¨}, and to make that explicit, the symbol @code{âŠ¢}, like this:
@example
lemma â€œXL.1â€. formula ğ‘¨. âŠ¢ ğ‘¨ â‡’ ğ‘¨.
@end example
These two forms are treated as though equivalent by adding the @code{âŠ¢} internally in implicit conversions at need.

The next step is to add a proof and let MLI verify it. For that, the statement must be put in a theory, and the theory LL must be included. The full example comes with the distribution. For your convenience, the proof is added; we start with a long proof:
@example
lemma â€œXL.1â€. formula ğ‘¨. ğ‘¨ â‡’ ğ‘¨.
proof.
  1. ((ğ‘¨ â‡’ ((ğ‘¨ â‡’ ğ‘¨) â‡’ ğ‘¨)) â‡’ ((ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘¨)) â‡’ (ğ‘¨ â‡’ ğ‘¨))) by A2.
  2. ğ‘¨ â‡’ ((ğ‘¨ â‡’ ğ‘¨) â‡’ ğ‘¨) by A1.
  3. (ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘¨)) â‡’ (ğ‘¨ â‡’ ğ‘¨) by MP, 1, 2.
  4. ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘¨) by A1.
  conclusion by MP, 3, 4.
âˆ
@end example
Now run @code{mli} on the input file, and check the output in the corresponding @code{.mlo} file, to see that it has been verified: MLI writes the parts that failed with @code{[*unproved*]}, so if no such parts are found, the proof passed.


@cindex non-termination
@cindex breadth-first proof tree search
@cindex proof tree search, breadth-first
@cindex search, breadth-first proof tree
@cindex redundant proof line
@cindex proof line, redundant

To see how this works, take away the @code{MP} (along with the trailing comma) in the example code above, rerun @code {mli}, and recheck the @code{.mlo} file. Then these lines along with the statement itself will be marked with @code{[*unproved*]}. If one leaves the @code{MP}, and takes away something else, then MLI will end up in non-termination, or an infinite, unending, proof search: As modus ponens MP can always be used in a search, it will cause the proof tree to expand exponentially, until computer resources run out, or a limit in the program is reached. There seem to be no simple way around this, with respect to MP, but to be careful with the use of modus ponens MP.

Since MLI tries to prove all lines, this will happen if one line has this type of proof error. However, it may happen that one proof line fails, but it is not required for the proof of the statement, being redundant. Then MLI will mark this proof line with @code{[*unproved*]}, and add an additional comment that it was needed in the proof of the statement. To see this, alter the statement above to
@example
lemma â€œXL.1â€. formula ğ‘¨. ğ‘¨ â‡’ ğ‘¨.
proof.
  1. ((ğ‘¨ â‡’ ((ğ‘¨ â‡’ ğ‘¨) â‡’ ğ‘¨)) â‡’ ((ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘¨)) â‡’ (ğ‘¨ â‡’ ğ‘¨))) by A2.
  2. ğ‘¨ â‡’ ((ğ‘¨ â‡’ ğ‘¨) â‡’ ğ‘¨) by A1.
  3. (ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘¨)) â‡’ (ğ‘¨ â‡’ ğ‘¨) by MP, 1, 2.
  3a. (ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘¨)) â‡’ (ğ‘¨ â‡’ ğ‘¨) by 1, 2.
  4. ğ‘¨ â‡’ (ğ‘¨ â‡’ ğ‘¨) by A1.
  conclusion by MP, 3, 3a, 4.
âˆ
@end example
Here, the proof is identical to the one before, except that a proof line @code{3a} is added, which cannot be proved as MP has been removed, and it is further called for in the @code{conclusion} proof line. Then rerun @code{mli} and check the @code{.mlo} file it writes. This time, MLI does not end up in non-termination, as there actually is a proof. The proof line @code{3a} is marked @code{[*unproved*]}, and right before the end of proof marker @code{âˆ}, there is the comment
@example
[*Statement is proved, but some proof lines are unproved.*]
@end example

As the list of statements in each proof line is but a suggestion to MLI what to search when constructing the proof tree, it continues to search even after it has found a failing line. It is also possible that a proof line is proved, but not required in the statement proof, or one might even want to look for more than one proof, though the default is to just find one, which usually is a short one, in view of the breadth-first proof tree search.

Now, let's make a short proof: From the proof above, we can see that it is proved using A1, A2 and MP. As MLI uses a breadth-first proof tree search. So write
@example
lemma â€œXL.1â€. formula ğ‘¨. ğ‘¨ â‡’ ğ‘¨.
proof.
  conclusion by A1, A2, MP.
âˆ
@end example
Then rerun @code{mli} and check the @code {.mlo} file to verify it has been proved.

Even though this style of proof is more like that of mathematicians coming by and giving a talk, it might be good to get to know the details sometimes, and also verify that the proof is correct by hand. So reverse this process: getting a long, detailed proof from the short, condensed one, and along with that, the substitutions used. So change the above code, by inserting the debugging commands @code{trace_result}â€¦@code{untrace_result}, to
@example
trace_result
lemma â€œXL.1â€. formula ğ‘¨. ğ‘¨ â‡’ ğ‘¨.
proof.
  conclusion by A1, A2, MP.
âˆ
untrace_result
@end example
Then rerun @code{mli}, and this time check the @code{.log} file:

Here, @code{trace_result} turns on writing the proof results to the @code{.log} file, and @code{untrace_result} turns it off again, to avoid this file becoming too large and hard to read. These debugging commands are not a part of the language itself, but the lexer just puts on/off a suitable flag for the purpose. So they can be put just about anywhere in the input file, but as the parser may use a lookahead token, the flag may be altered out sync with what is expected. In particular, the parser may decide to read the next token after the @code{âˆ} before starting to write out the proof, and then @code{untrace_result} will be turned off when the write out starts. So if that happens, @code{untrace_result} must be moved to a later point in the input code, one language token should suffice.

The code in the @code{.log} file looks something like this:
@example
Proving lemma XL.1. formula ğ‘¨.
  âŠ¢ ğ‘¨ â‡’ ğ‘¨.
Proving conclusion.
Proof succeeded.
Variable: ğ‘¨
Proof count: 1

Proof of
  ğ‘¨ â‡’ ğ‘¨
succeeded:
  MP: A1; MP: A1; A2.
rule MP. formula ğ‘¨â‚â‚€, ğ‘©â‚â‚€.
  ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ ğ‘©â‚â‚€ âŠ¢ ğ‘©â‚â‚€.
[ğ‘©â‚â‚€ â†¦ ğ‘¨ â‡’ ğ‘¨]
 âŠ£ ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ (ğ‘¨ â‡’ ğ‘¨)
axiom A1. formula ğ‘¨â‚‚â‚€, ğ‘©â‚‚â‚€.
  âŠ¢ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€).
rule MP. formula ğ‘¨â‚‚â‚, ğ‘©â‚‚â‚.
  ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ğ‘©â‚‚â‚ âŠ¢ ğ‘©â‚‚â‚.
[ğ‘¨â‚â‚€ â†¦ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)][ğ‘©â‚‚â‚ â†¦ (ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨)]
 âŠ£ ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
axiom A1. formula ğ‘¨â‚ƒâ‚€, ğ‘©â‚ƒâ‚€.
  âŠ¢ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€).
axiom A2. formula ğ‘¨â‚ƒâ‚, ğ‘©â‚ƒâ‚, ğ‘ªâ‚ƒâ‚.
  âŠ¢ (ğ‘¨â‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ ((ğ‘¨â‚ƒâ‚ â‡’ ğ‘©â‚ƒâ‚) â‡’ (ğ‘¨â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)).
[ğ‘¨â‚‚â‚ â†¦ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€)][ğ‘¨â‚ƒâ‚€ â†¦ ğ‘¨â‚ƒâ‚][ğ‘©â‚ƒâ‚€ â†¦ ğ‘©â‚ƒâ‚][ğ‘¨â‚ƒâ‚ â†¦ ğ‘ªâ‚ƒâ‚][ğ‘¨â‚‚â‚€ â†¦ ğ‘ªâ‚ƒâ‚][ğ‘©â‚ƒâ‚ â†¦ ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚][ğ‘ªâ‚ƒâ‚ â†¦ ğ‘¨]
âˆ
@end example


@cindex proof line

Let's jog through the different components of this output. The first part
@example
Proving lemma XL.1. formula ğ‘¨.
  âŠ¢ ğ‘¨ â‡’ ğ‘¨.
Proving conclusion.
Proof succeeded.
Variable: ğ‘¨
@end example
gives the statement, and the following line @code{Proving conclusion} says which proof line of the full proof it concerns, in this case the conclusion part of the proof, as the proof only has one line. After that, a list of the variables in the statement.

The lines that follow
@example
Proof of
  ğ‘¨ â‡’ ğ‘¨
succeeded:
  MP: A1; MP: A1; A2.
@end example
gives the statement of the proof line, says that the proof succeeded, and gives a description of the proof search it found: Each part delimited by semicolons is a sequence of statements used to transform the list of goals to a new list of goals. The colons separates the different levels in the proof tree. One can also use commas betweem the smicolons, specifying a set of statements to be used in the search. This will occur in the case of definitions, that later the behavior of the unifier, rather than causing specific unification. Thus, the this is a specification for a single branch in the proof search tree.

It is in fact possible to enter such semicolons into the statement of the proof, helping the engine to limit the search, taking up less computer resources in terms of time and space. The alternate form in the @code{.mlo} file would be
@example
lemma â€œXL.1â€. formula ğ‘¨. ğ‘¨ â‡’ ğ‘¨.
proof.
  conclusion by MP: A1; MP: A1; A2.
âˆ
@end example
The output in the @code{.mlo} will be different, giving the semicolons as well, but the output into the @code{.log} by @code{trace_result} will not change, as this is what the program does anyway.

The last part, up to the end of proof marker @code{âˆ}, shows a number of reductions to already proved statements. It gives the substitutions found, along with details of the variable renumbering of the applied statements.
@example
rule MP. formula ğ‘¨â‚â‚€, ğ‘©â‚â‚€.
  ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ ğ‘©â‚â‚€ âŠ¢ ğ‘©â‚â‚€.
[ğ‘©â‚â‚€ â†¦ ğ‘¨ â‡’ ğ‘¨]
 âŠ£ ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ (ğ‘¨ â‡’ ğ‘¨)
axiom A1. formula ğ‘¨â‚‚â‚€, ğ‘©â‚‚â‚€.
  âŠ¢ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€).
rule MP. formula ğ‘¨â‚‚â‚, ğ‘©â‚‚â‚.
  ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ğ‘©â‚‚â‚ âŠ¢ ğ‘©â‚‚â‚.
[ğ‘¨â‚â‚€ â†¦ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)][ğ‘©â‚‚â‚ â†¦ (ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨)]
 âŠ£ ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
axiom A1. formula ğ‘¨â‚ƒâ‚€, ğ‘©â‚ƒâ‚€.
  âŠ¢ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€).
axiom A2. formula ğ‘¨â‚ƒâ‚, ğ‘©â‚ƒâ‚, ğ‘ªâ‚ƒâ‚.
  âŠ¢ (ğ‘¨â‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ ((ğ‘¨â‚ƒâ‚ â‡’ ğ‘©â‚ƒâ‚) â‡’ (ğ‘¨â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)).
[ğ‘¨â‚‚â‚ â†¦ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€)][ğ‘¨â‚ƒâ‚€ â†¦ ğ‘¨â‚ƒâ‚][ğ‘©â‚ƒâ‚€ â†¦ ğ‘©â‚ƒâ‚][ğ‘¨â‚ƒâ‚ â†¦ ğ‘ªâ‚ƒâ‚][ğ‘¨â‚‚â‚€ â†¦ ğ‘ªâ‚ƒâ‚][ğ‘©â‚ƒâ‚ â†¦ ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚][ğ‘ªâ‚ƒâ‚ â†¦ ğ‘¨]
âˆ
@end example
These variables should be read as matrix component numbers, so @code{ğ‘©â‚‚â‚ƒ} is â€œB two threeâ€. If the index numbers require two digits, they will be separated by a subscript "+", and there may be a superscript number for nested proof depth and a third subscript number for definition degree, as well.

The actual numbers are other otherwise irrelevant, except for that the same renamed variable gets the same number everywhere: Whenever a proved statement is applied, its variables are renumbered, so as to not clash with any existing variables. The use of multiple indices is just one way to implement it; a single index, or some other method to avoid variable clashes, might do just as well.

Let's work these substitutions by hand, in part to see how it works, and to check that the program did it right. The first part is
@example
  ğ‘¨ â‡’ ğ‘¨
rule MP. formula ğ‘¨â‚â‚€, ğ‘©â‚â‚€.
  ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ ğ‘©â‚â‚€ âŠ¢ ğ‘©â‚â‚€.
[ğ‘©â‚â‚€ â†¦ ğ‘¨ â‡’ ğ‘¨]
 âŠ£ ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ (ğ‘¨ â‡’ ğ‘¨)
@end example
with the first line the statement be proved, and the next modus ponens MP with the variables renumbered. Thereafter follows a substitution, followed by the new list of goals, marked by a @code{âŠ£}, resulting in the application of it:
@example
[ğ‘©â‚â‚€ â†¦ ğ‘¨ â‡’ ğ‘¨]
 âŠ£ ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ (ğ‘¨ â‡’ ğ‘¨)
@end example
Here, the substitution has only one components @code{[ğ‘©â‚â‚€ â†¦ ğ‘¨ â‡’ ğ‘¨]}, but if there are several such brackets, they are applied from left to right. Replacing @code{ğ‘©â‚â‚€}Â with @code{ğ‘¨ â‡’ ğ‘¨} in the renumbered MP does result in
@example
 âŠ£ ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ (ğ‘¨ â‡’ ğ‘¨)
@end example
so so far, it is all right.

The next part is
@example
 âŠ£ ğ‘¨â‚â‚€, ğ‘¨â‚â‚€ â‡’ (ğ‘¨ â‡’ ğ‘¨)
axiom A1. formula ğ‘¨â‚‚â‚€, ğ‘©â‚‚â‚€.
  âŠ¢ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€).
rule MP. formula ğ‘¨â‚‚â‚, ğ‘©â‚‚â‚.
  ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ğ‘©â‚‚â‚ âŠ¢ ğ‘©â‚‚â‚.
[ğ‘¨â‚â‚€ â†¦ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)][ğ‘©â‚‚â‚ â†¦ (ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨)]
 âŠ£ ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
@end example
Here, the substitution has two brackets, and as noted above, they should applied left to right, so first @code{[ğ‘¨â‚â‚€ â†¦ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)]}, and thereafter @code{[ğ‘©â‚‚â‚ â†¦ (ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨)]}. Applying the first one to the list of goals to be proved at the top, and marked with @code{âŠ£}, gives
@example
 âŠ£ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€), (ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨)
@end example
while applying it to the renumbered MP results in nothing as it does not contain the variable @code{ğ‘¨â‚â‚€}. Applying the second substitution to the list of goals does not change the latter, as it does not contain the variable @code{ğ‘©â‚‚â‚}, but when applied to MP, there results
@example
rule MP. formula ğ‘¨â‚‚â‚ƒ, ğ‘©â‚‚â‚ƒ.
  ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨)) âŠ¢ (ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨).
@end example

Now, the first goal @code{âŠ£ ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)} is valid by axiom A1, and the second goal @code{âŠ£ (ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨)} can by the substituted MP, replacing the conclusion (or head) by the premise (or body), be replaced by
@example
 âŠ£ ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
@end example
which indeed the program statement above from the reductions of axiom A1 and rule MP.

The final reduction is then
@example
 âŠ£ ğ‘¨â‚‚â‚, ğ‘¨â‚‚â‚ â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
axiom A1. formula ğ‘¨â‚ƒâ‚€, ğ‘©â‚ƒâ‚€.
  âŠ¢ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€).
axiom A2. formula ğ‘¨â‚ƒâ‚, ğ‘©â‚ƒâ‚, ğ‘ªâ‚ƒâ‚.
  âŠ¢ (ğ‘¨â‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ ((ğ‘¨â‚ƒâ‚ â‡’ ğ‘©â‚ƒâ‚) â‡’ (ğ‘¨â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)).
[ğ‘¨â‚‚â‚ â†¦ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€)][ğ‘¨â‚ƒâ‚€ â†¦ ğ‘¨â‚ƒâ‚][ğ‘©â‚ƒâ‚€ â†¦ ğ‘©â‚ƒâ‚][ğ‘¨â‚ƒâ‚ â†¦ ğ‘ªâ‚ƒâ‚][ğ‘¨â‚‚â‚€ â†¦ ğ‘ªâ‚ƒâ‚][ğ‘©â‚ƒâ‚ â†¦ ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚][ğ‘ªâ‚ƒâ‚ â†¦ ğ‘¨]
âˆ
@end example

The substitution is now a bit longer, having seven brackets, but applying it to the two goals top in the example gives
@example
-- By [ğ‘¨â‚‚â‚ â†¦ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€)]:
 âŠ£ ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€), (ğ‘¨â‚ƒâ‚€ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚€)) â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
-- By [ğ‘¨â‚ƒâ‚€ â†¦ ğ‘¨â‚ƒâ‚]:
 âŠ£ ğ‘¨â‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚), (ğ‘¨â‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚€ â‡’ ğ‘¨â‚ƒâ‚)) â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
-- By [ğ‘©â‚ƒâ‚€ â†¦ ğ‘©â‚ƒâ‚]:
 âŠ£ ğ‘¨â‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘¨â‚ƒâ‚), (ğ‘¨â‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘¨â‚ƒâ‚)) â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
-- By [ğ‘¨â‚ƒâ‚ â†¦ ğ‘ªâ‚ƒâ‚]:
 âŠ£ ğ‘ªâ‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚), (ğ‘ªâ‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ ((ğ‘¨â‚‚â‚€ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨â‚‚â‚€)) â‡’ (ğ‘¨ â‡’ ğ‘¨))

-- By [ğ‘¨â‚‚â‚€ â†¦ ğ‘ªâ‚ƒâ‚]:
 âŠ£ ğ‘ªâ‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚), (ğ‘ªâ‚ƒâ‚ â‡’ (ğ‘©â‚ƒâ‚ â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ ((ğ‘ªâ‚ƒâ‚ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
-- By [ğ‘©â‚ƒâ‚ â†¦ ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚]:
 âŠ£ ğ‘ªâ‚ƒâ‚ â‡’ ((ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚) â‡’ ğ‘ªâ‚ƒâ‚), (ğ‘ªâ‚ƒâ‚ â‡’ ((ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚) â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ ((ğ‘ªâ‚ƒâ‚ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘ªâ‚ƒâ‚)) â‡’ (ğ‘¨ â‡’ ğ‘¨))

-- By [ğ‘ªâ‚ƒâ‚ â†¦ ğ‘¨]:
 âŠ£ ğ‘¨ â‡’ ((ğ‘©â‚‚â‚€ â‡’ ğ‘¨) â‡’ ğ‘¨), (ğ‘¨ â‡’ ((ğ‘©â‚‚â‚€ â‡’ ğ‘¨) â‡’ ğ‘¨)) â‡’ ((ğ‘¨ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨)) â‡’ (ğ‘¨ â‡’ ğ‘¨))
âˆ
@end example
The same substitution applied to the renumbered axiom A1 gives
@example
  âŠ¢ ğ‘¨ â‡’ ((ğ‘©â‚‚â‚€ â‡’ ğ‘¨) â‡’ ğ‘¨).
@end example
proving the first goal, and applied to the renumbered axiom A2 gives
@example
  âŠ¢ (ğ‘¨ â‡’ ((ğ‘©â‚‚â‚€ â‡’ ğ‘¨) â‡’ ğ‘¨)) â‡’ ((ğ‘¨ â‡’ (ğ‘©â‚‚â‚€ â‡’ ğ‘¨)) â‡’ (ğ‘¨ â‡’ ğ‘¨)).
@end example
which is the second goal.

Thus, this series of reductions led to a proof.

â€” Timing of the different proof versions.


@node Nested proofs
@subsection Nested proofs

@cindex nested proof
@cindex proof, nested
@cindex subproof
@cindex depth

A statement proof can be nested with subproofs, to facilitate writing writing proofs by hand, but are otherwise logically equivalent to unnested proofs. It is a common style, when writing proofs by hand, to make intermediate statements that are proved, and then picked together in the full proof of the statement, and supporting that, helps making proofs structured, and requires less work when translating a handwritten proof into code.

A substatement with subproof is called @code{claim}, which in turn can have further nested levels, here called the @dfn{depth}, of statements and proofs.



@node Input File
@chapter MLI Input Files


@node Interface
@chapter User Interface.


@node Algorithm
@chapter The MLI Inference Algorithm.


@node Debugging
@chapter Understanding and Debugging MLI Source Code.


@c ================================================= Invoking MLI

@node Invocation
@chapter Invoking MLI

@cindex invoking MLI
@cindex MLI invocation
@cindex options for invoking MLI

The usual way to invoke MLI is as follows:
@example
mli @var{infile}
@end example

Here @var{infile} is the input file name, which usually ends in
@samp{.mli}. This file can in turn include other files, like libraries.
If the parsing and interpretation are successful, two output files
are produced: One, by default ending in @samp{.mlo}, with pretty-printing of the
statements processed and their provability status indicated, and a log file,
by default ending in @samp{.log}, with proving process details, as
chosen by the tracing commands in the input files.

If @var{infile} does not end with @samp{.mli}, then @samp{.mlo} resp. @samp{.log}
are merely appended to the whole name, which also becomes the theory name. These
names can be overridden by the options below.

@menu
* MLI Options::     The options described in detail,
* Option Cross Key::  Long alphabetical list of options.
@end menu


@node MLI Options
@section MLI Options

MLI supports only modern option names beginning with indicated with @samp{--}.

For processing, an input file must be given, with optional prefix @code{--input=}.

@table @option

@item --help
Display help text, including a command line options summary, and exit.

@item --version
Output version and program information, and exit


@item [--input=]@var{file}
Read input from @var{file}. The prefix @code{--input=} is optional.
If @var{file} ends with @samp{.mli}, the @var{filename
base} is what precedes it, otherwise, it is the whole infile filename.
The @var{filename base} is used to determine the default names for the output files.

@item --output=@var{file}
Write output to @var{file}. If this option is not given, the output file name is the
@var{filename base} followed by @samp{.mlo}.

@item --log=@var{file}     
Write log output to @var{file}. If this option is not given, the log file name is the
@var{filename base} followed by @samp{.log}.

@item --include=@var{dir}
Add include directory @var{dir}, ahead of the default library directory named in the variable
@code{DATADIR} passed to the Makefile.
Multiple occurrences will cause the directories to
be searched in the same order as they are given, left-to-right, on the command line.
The name @var{dir} is passed as is to the shell, though if it does not end with
@code{/}, it is added in the search.

@item --theory=@var{name}
Name the input file theory database to @var{name}. If this option is not given, the
theory name is the same as the @var{filename base}.

@item --verbose
More information to the standard output.


@end table


@node Option Cross Key
@section Option Cross Key

Alphabetical list of options.


@c ==== Table of Symbols ====

@node Table of Symbols
@appendix MLI Symbols
@cindex MLI symbols, table of
@cindex symbols in MLI, table of


@deffn {Symbol} theorem
Indicates a named theorem.
@end deffn


@node Glossary
@appendix Glossary
@cindex glossary

@table @asis
@item Theorem
A statement that is true in the object theory. A theorem may or may not have a proof,
and in the latter case, there is in general no way to determine whether it is true.
@end table


@node Bibliography
@unnumbered Bibliography

@table @asis

@item [Kleene 1952]
Stephen Cole Kleene, "Introduction to Metamathematics", 1952, seventh reprint 1974,
North Holland ISBN 978-0-7204-2103-3, American Elsevier ISBN 978-0-444-10088-7.

@item [Mendelson 1964]
Elliott Mendelson, "Introduction to Mathematical Logic", 1964, first edition, Van Nostrand, 
Library of Congress Control Number ISBN 9780442053000.

@end table


@node Index of Terms
@unnumbered Index of Terms

@printindex cp

@bye




